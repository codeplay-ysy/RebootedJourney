
## 复习一下git，哪些我没记住？
连接远程仓库的操作
git remote add origin git@github.com:name/respository.git
工作区文件的四种状态
- 未跟踪 (用git add .)
- 未修改
- 已修改
- 已暂存
从已修改到已暂存再到未修改，这样就实现了更新。
用`git status`来进行检查

`git remote add origin <repo-address>`一个本地仓库是可以连接多个远程仓库的，这里会把origin配置成指定远程仓库的地址。也就是说origin可以替换成别的名字并且和指定的远程仓库进行连接。
![输入图片说明](/imgs/2023-09-20/rpZWYFtQmWvmZkpd.png)
`git push origin main`和`git push git@github.com:name/repo.git main`其实是等价的。（关于origin的一个解释）

`git push origin "分支名"`提交到指定分支


`git add` 从未跟踪到跟踪，从修改到暂存，从冲突到解决
说到冲突，主要就在于，`merge`这个指令。无论是远程分支合并，还是`pull`指令（`pull = fetch + 本地的merge`）。
`git branch`查看本地分支
`git branch -r`查看远程分支
`git branch branchname`创建分支


 **HEAD是对当前commit-ID的引用**
![输入图片说明](/imgs/2023-09-20/awQhFK47o61oyf2E.png)


***`git reset`***

`git reset`其实就是通过移动HEAD来进行撤销。

`git reset --hard`会将暂存区和工作区都重设为HEAD
`git reset --soft`只改变HEAD
`git reset (--mixed)`将暂存区的修改退回到工作区
![输入图片说明](/imgs/2023-09-21/6tGjm4MqNYguhK5H.png)

![输入图片说明](/imgs/2023-09-21/BWgdOCca4wRWkvss.png)
`git commit -a `可以跳过`add`

先用`git log`获取指定HEAD，然后可以`git reset 指定版号`
![输入图片说明](/imgs/2023-09-21/pLmEMYCVrix1ONUp.png)

---
修改配置以按照汉字形式显示文件名，而不是编码形式
![](/imgs/2023-09-21/OBpIY8yikqaQW3Ze.png)
![输入图片说明](/imgs/2023-09-21/bnkpWthsAF1b1dpH.png)
如果`git reset` 出问题，可以用以下指令撤销回退:
`git reset --hard ORIG_HEAD`
![输入图片说明](/imgs/2023-09-21/Jwf2EiUFY8Ua802e.png)

**HEAD相关的还有:**
Detached HEAD(游离HEAD)
- `git checkout`跳转到当前无分支指向的commit-ID的时候会发生
- `git checkout`到远程分支也会发生

**rebase:**
`git pull origin master:feature --rebase`
rebase改变基分支，从master上拉取的feature，之后master和feature分别进行了修改，rebase会将feature上的修改追加到master修改的后面，形成新的feature分支为基分支。

**fetch:**
`git fetch origin`
`git fetch origin main`
`git fetch origin main:main`(后者为本地分支名)

![1111](/imgs/2023-09-21/sVj3YZEPcwiqVx9O.png)

算法复习
---
### 插入排序
(for 循环先循环再自增自减）
```
#include <stdio.h>

  

int main() {

int arr[10] = {123, 23, 231, 2, 45, 25, 23, 1, 24, 3};

int n, i, j, key;

  

for (i = 1; i < 10; i++) {

key = arr[i];//保留住当前的值

j = i - 1;

while (j >= 0 && arr[j] > key) {//比较的时候都是和key比较，这和希尔算法一样的

arr[j + 1] = arr[j];//这里arr[i]被用了，所以前面要key

j--;

}

arr[j + 1] = key;

}

for (i = 0; i < 10; i++) {

printf("%d ", arr[i]);

}

  

return 0;

}
```
插排在相对有序的情况下要比冒泡好，因为插入排序会判断是否需要交换，而冒泡是不断进行遍历。


### 希尔排序
```
void Shell_Sort(int arr[],int len) {
	int i, j, tmp, gap;
	for(gap = len >> 1; gap > 0; gap >>= 1){
		for(i = gap; i < len; i++){
			tmp = arr[i];	
			for(j = i - gap; j >= 0 && arr[j] > tmp; j -= gap)
				arr[j+gap] = arr[j];
			arr[j+gap] = tmp;
		}
	}
}
```
### 归并排序
#### 迭代：
```
int min(int a,int b){
return a < b ? a : b;
}

void merge_sort_1(int arr[],int len){
	int *a = arr;
	int *b = (int *) malloc(len *sizeof(int));
	int seg,start;
	for(seg = 1;seg < len; seg += seg){
		for(start = 0; start < len;start += 2 * seg){
			int low = start, mid = min(start + seg, len), high = min(start + 2 * seg, len);
			int k = low;
			int start1 = low, end1 = mid;
			int start2 = mid, end2 = high;
			while(start1 < end1 && start2 < end2)
				b[k++] = a[start1] < a[start2] ? a[start1++] : a[start2++];
			while(start1 < end1)
				b[k++] = a[start1++];
			while(start2 < end2)
				b[k++] = a[start2++];
			}
		int *temp = a;
		a = b;
		b = temp;
	}
	int i;
	if (a != arr){
		for (i < 0; i < len; i++){
			a[i] = b[i];
			b = a;
	}
	free(b);
}

```
#### 递归：
```
int min(int a,int b){

return a < b ? a : b;

}

void merge_sort_1(int arr[],int len){

int *a = arr;

int *b = (int *) malloc(len *sizeof(int));

int seg,start;

for(seg = 1;seg < len; seg += seg){

for(start = 0; start < len;start += 2 * seg){

int low = start, mid = min(start + seg, len), high = min(start + 2 * seg, len);

int k = low;

int start1 = low, end1 = mid;

int start2 = mid, end2 = high;

while(start1 < end1 && start2 < end2)

b[k++] = a[start1] < a[start2] ? a[start1++] : a[start2++];

while(start1 < end1)

b[k++] = a[start1++];

while(start2 < end2)

b[k++] = a[start2++];

  

}

int *temp = a;

a = b;

b = temp;

}

int i;

if (a != arr){

for (i < 0; i < len; i++)

a[i] = b[i];

b = a;

}

free(b);

}

void merge_sort_2(int arr[], int reg[], int left, int right){
	if(left > right)
		return;
	int len = right - left,mid = len >> 1 + left;
	int start1 = left, end1 =mid;
	int start2 = mid+1, end2 = right;
	merge_sort_2(arr, reg, start1, end1);
	merge_sort_2(arr, reg, start2, end2);
	int k = left;
	while(start1 <= end1 && start2 <= end2)
		reg[k++] = arr[start1] < arr[end1] ? arr[start1++] : arr[end1++];
	while(start1 <= end1)
		reg[k++] = arr[start1++];
	while(start2 <= end2)
		reg[k++] = arr[start2++];
	for (k = left; k <= right; k++)
		arr[k] = reg[k];
}
```
### 快排
```
typedef struct _Range{

int start, end;

} Range;

void swap(int *x, int *y) {

int t = *x;

*x = *y;

*y = t;

}

Range new_range(int left, int right){

Range r;

r.start = left;

r.end = right;

return r;

}

void Quick_Sort_1(int arr[],int len){

if(len <= 0)

return;

Range reg[len];

int p = 0;

reg[p++] = new_range(0, len - 1);//创建新的range

while (p) {

Range range = reg[--p];//我们创建了一个Range数组，所以每循环一次，就p--，这样就会实现一个栈式的顺序进行了排列。

if(range.start >= range.end)

continue;

int mid = arr[(range.start + range.end) / 2];

int left = range.start, right = range.end;

do {

while (arr[left] < mid) ++left;

while (arr[right] > mid) --right;

if (left <= right) {

swap(&arr[left], &arr[right]);

left++;

right--;

}

} while(left <= right);

if (range.start < right) reg[p++] = new_range(range.start, right);

if (range.end > left) reg[p++] = new_range(left, range.end);//这里将接下来需要的循环排进数组，根据p--依次完成接下来的运算循环

}

}
```

## 看看socket编程
### 互联网分层模型：
应用层-->HTTP协议等
表示层、会话层-->socket协议
传输层-->端口，UDP、TCP协议
网络层-->IP协议
数据链路层-->MAC地址，网卡
物理层-->光纤等

---
`net.Conn`是个接口，代表面向流的网络连接（就是如TCP连接这种，通过一个可靠的双向的连续字节流进行数据传输）。
`Conn`接口包括`Read`、`Write`、`Close`、`LocalAddr`、`RemoteAddr`
以及设置deadline的三种方法

---
`bufio.Reader`是对`io.Reader`的一个包装
```
type Reader struct {
    buf          []byte
    rd           io.Reader // reader provided by the client
    r, w         int       // buf read and write positions
    err          error
    lastByte     int       // 最后一个读取的字节，用于UnreadByte操作
    lastRuneSize int       // 最后一个读取rune的大小，用于UnreadRune操作
}
func NewReader(rd io.Reader) *Reader{...}
func (b *Reader) ReadString(a byte) (string, error)//根据a这个标识符来分割分隔，比如'\n'
func (b *Reader) ReadSlice(a byte) (line []byte, err error)//根据关键词a切片
//还有ReadByte等各种方法，以此类推
```
(先了解到这)

---
`bytes`包和`strings`包的相关方法基本一致
`bytes.Trim(s []byte, cutset string) []byte`删除s切片中的cutset字段
同类的还有
`bytes.TrimLeft`
`bytes.TrimRight`
`bytes.TrimPrefix`
`bytes.TrimSuffix`等等

---
## gin 和 gorm 的一些操作
### gin
#### **gin有关router的一些操作**
```
//初始化操作，方便添加新的路由
package routers


import "github.com/gin-gonic/gin"

type Register func(e *gin.Engine)

func Init(routers ...Register) *gin.Engine {

rs := append([]Register{}, routers...)

r := gin.New()

for _, register := range rs {

register(r)

}

return r

}
```

```
//这是用来加载路由的。可以每次编写一组路由对应一个loadrouter
package routers

  

import "github.com/gin-gonic/gin"

  

func LoadRouter1(e *gin.Engine) {

v1 := e.Group("v1")

{

v1.GET("/yes", Sayyes)

}

}
```
---

#### **gin获取请求参数的一些操作**
GET获取请求参数：
`username := c.Query("username")`
POST获取请求参数--Form表单:
`username := c.PostForm("username")`
POST获取请求参数--JSON:

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTgwMTA0MjYyNiwyMDA5ODMzMzgzLC0xMT
cxNjUwMDYwLC0xODc0MDAwMjY4LDE5ODYwOTEyOTEsMjAzMzU5
Nzk5MSwtODg0MTQ0NTc1LDI4MzExMzE1Niw1NDI5NDExNjQsLT
EwMjAwMjg0NzgsLTEwNDMzOTY1ODMsNzUzOTk0NDY5LC0xMTcx
MDY4ODM2LC0zMTYwMjEyMDgsNjg4Nzg3NDI4LDExNzMzNjkxMD
UsLTE4ODMxMjkxOTQsLTEwMDAyNjMwNjQsLTIwNDkyMjU4Myw4
MTk4MDQ3MjRdfQ==
-->