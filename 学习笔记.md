
## 复习一下git，哪些我没记住？
连接远程仓库的操作
git remote add origin git@github.com:name/respository.git
工作区文件的四种状态
- 未跟踪 (用git add .)
- 未修改
- 已修改
- 已暂存
从已修改到已暂存再到未修改，这样就实现了更新。
用`git status`来进行检查

`git remote add origin <repo-address>`一个本地仓库是可以连接多个远程仓库的，这里会把origin配置成指定远程仓库的地址。也就是说origin可以替换成别的名字并且和指定的远程仓库进行连接。
![输入图片说明](/imgs/2023-09-20/rpZWYFtQmWvmZkpd.png)
`git push origin main`和`git push git@github.com:name/repo.git main`其实是等价的。（关于origin的一个解释）

`git push origin "分支名"`提交到指定分支


`git add` 从未跟踪到跟踪，从修改到暂存，从冲突到解决
说到冲突，主要就在于，`merge`这个指令。无论是远程分支合并，还是`pull`指令（`pull = fetch + 本地的merge`）。
`git branch`查看本地分支
`git branch -r`查看远程分支
`git branch branchname`创建分支


 **HEAD是对当前commit-ID的引用**
![输入图片说明](/imgs/2023-09-20/awQhFK47o61oyf2E.png)


***`git reset`***

`git reset`其实就是通过移动HEAD来进行撤销。

`git reset --hard`会将暂存区和工作区都重设为HEAD
`git reset --soft`只改变HEAD
`git reset (--mixed)`将暂存区的修改退回到工作区
![输入图片说明](/imgs/2023-09-21/6tGjm4MqNYguhK5H.png)

![输入图片说明](/imgs/2023-09-21/BWgdOCca4wRWkvss.png)
`git commit -a `可以跳过`add`

先用`git log`获取指定HEAD，然后可以`git reset 指定版号`
![输入图片说明](/imgs/2023-09-21/pLmEMYCVrix1ONUp.png)

---
修改配置以按照汉字形式显示文件名，而不是编码形式
![](/imgs/2023-09-21/OBpIY8yikqaQW3Ze.png)
![输入图片说明](/imgs/2023-09-21/bnkpWthsAF1b1dpH.png)
如果`git reset` 出问题，可以用以下指令撤销回退:
`git reset --hard ORIG_HEAD`
![输入图片说明](/imgs/2023-09-21/Jwf2EiUFY8Ua802e.png)

**HEAD相关的还有:**
Detached HEAD(游离HEAD)
- `git checkout`跳转到当前无分支指向的commit-ID的时候会发生
- `git checkout`到远程分支也会发生

**rebase:**
`git pull origin master:feature --rebase`
rebase改变基分支，从master上拉取的feature，之后master和feature分别进行了修改，rebase会将feature上的修改追加到master修改的后面，形成新的feature分支为基分支。

**fetch:**
`git fetch origin`
`git fetch origin main`
`git fetch origin main:main`(后者为本地分支名)

![1111](/imgs/2023-09-21/sVj3YZEPcwiqVx9O.png)

算法复习
---
### 插入排序
(for 循环先循环再自增自减）
```
#include <stdio.h>

  

int main() {

int arr[10] = {123, 23, 231, 2, 45, 25, 23, 1, 24, 3};

int n, i, j, key;

  

for (i = 1; i < 10; i++) {

key = arr[i];//保留住当前的值

j = i - 1;

while (j >= 0 && arr[j] > key) {//比较的时候都是和key比较，这和希尔算法一样的

arr[j + 1] = arr[j];//这里arr[i]被用了，所以前面要key

j--;

}

arr[j + 1] = key;

}

for (i = 0; i < 10; i++) {

printf("%d ", arr[i]);

}

  

return 0;

}
```
插排在相对有序的情况下要比冒泡好，因为插入排序会判断是否需要交换，而冒泡是不断进行遍历。


### 希尔排序
```
void Shell_Sort(int arr[],int len) {
	int i, j, tmp, gap;
	for(gap = len >> 1; gap > 0; gap >>= 1){
		for(i = gap; i < len; i++){
			tmp = arr[i];	
			for(j = i - gap; j >= 0 && arr[j] > tmp; j -= gap)
				arr[j+gap] = arr[j];
			arr[j+gap] = tmp;
		}
	}
}
```
### 归并排序
#### 迭代：
```
int min(int a,int b){
return a < b ? a : b;
}

void merge_sort_1(int arr[],int len){
	int *a = arr;
	int *b = (int *) malloc(len *sizeof(int));
	int seg,start;
	for(seg = 1;seg < len; seg += seg){
		for(start = 0; start < len;start += 2 * seg){
			int low = start, mid = min(start + seg, len), high = min(start + 2 * seg, len);
			int k = low;
			int start1 = low, end1 = mid;
			int start2 = mid, end2 = high;
			while(start1 < end1 && start2 < end2)
				b[k++] = a[start1] < a[start2] ? a[start1++] : a[start2++];
			while(start1 < end1)
				b[k++] = a[start1++];
			while(start2 < end2)
				b[k++] = a[start2++];
			}
		int *temp = a;
		a = b;
		b = temp;
	}
	int i;
	if (a != arr){
		for (i < 0; i < len; i++){
			a[i] = b[i];
			b = a;
	}
	free(b);
}

```
#### 递归：
```
int min(int a,int b){

return a < b ? a : b;

}

void merge_sort_1(int arr[],int len){

int *a = arr;

int *b = (int *) malloc(len *sizeof(int));

int seg,start;

for(seg = 1;seg < len; seg += seg){

for(start = 0; start < len;start += 2 * seg){

int low = start, mid = min(start + seg, len), high = min(start + 2 * seg, len);

int k = low;

int start1 = low, end1 = mid;

int start2 = mid, end2 = high;

while(start1 < end1 && start2 < end2)

b[k++] = a[start1] < a[start2] ? a[start1++] : a[start2++];

while(start1 < end1)

b[k++] = a[start1++];

while(start2 < end2)

b[k++] = a[start2++];

  

}

int *temp = a;

a = b;

b = temp;

}

int i;

if (a != arr){

for (i < 0; i < len; i++)

a[i] = b[i];

b = a;

}

free(b);

}

void merge_sort_2(int arr[], int reg[], int left, int right){
	if(left > right)
		return;
	int len = right - left,mid = len >> 1 + left;
	int start1 = left, end1 =mid;
	int start2 = mid+1, end2 = right;
	merge_sort_2(arr, reg, start1, end1);
	merge_sort_2(arr, reg, start2, end2);
	int k = left;
	while(start1 <= end1 && start2 <= end2)
		reg[k++] = arr[start1] < arr[end1] ? arr[start1++] : arr[end1++];
	while(start1 <= end1)
		reg[k++] = arr[start1++];
	while(start2 <= end2)
		reg[k++] = arr[start2++];
	for (k = left; k <= right; k++)
		arr[k] = reg[k];
}
```
### 快排
```
typedef struct _Range{

int start, end;

} Range;

void swap(int *x, int *y) {

int t = *x;

*x = *y;

*y = t;

}

Range new_range(int left, int right){

Range r;

r.start = left;

r.end = right;

return r;

}

void Quick_Sort_1(int arr[],int len){

if(len <= 0)

return;

Range reg[len];

int p = 0;

reg[p++] = new_range(0, len - 1);//创建新的range

while (p) {

Range range = reg[--p];//我们创建了一个Range数组，所以每循环一次，就p--，这样就会实现一个栈式的顺序进行了排列。

if(range.start >= range.end)

continue;

int mid = arr[(range.start + range.end) / 2];

int left = range.start, right = range.end;

do {

while (arr[left] < mid) ++left;

while (arr[right] > mid) --right;

if (left <= right) {

swap(&arr[left], &arr[right]);

left++;

right--;

}

} while(left <= right);

if (range.start < right) reg[p++] = new_range(range.start, right);

if (range.end > left) reg[p++] = new_range(left, range.end);//这里将接下来需要的循环排进数组，根据p--依次完成接下来的运算循环

}

}
```

## 看看socket编程
### 互联网分层模型：
应用层-->HTTP协议等
表示层、会话层-->socket协议
传输层-->端口，UDP、TCP协议
网络层-->IP协议
数据链路层-->MAC地址，网卡
物理层-->光纤等

---
`net.Conn`是个接口，代表面向流的网络连接（就是如TCP连接这种，通过一个可靠的双向的连续字节流进行数据传输）。
`Conn`接口包括`Read`、`Write`、`Close`、`LocalAddr`、`RemoteAddr`
以及设置deadline的三种方法

---
`bufio.Reader`是对`io.Reader`的一个包装
```
type Reader struct {
    buf          []byte
    rd           io.Reader // reader provided by the client
    r, w         int       // buf read and write positions
    err          error
    lastByte     int       // 最后一个读取的字节，用于UnreadByte操作
    lastRuneSize int       // 最后一个读取rune的大小，用于UnreadRune操作
}
func NewReader(rd io.Reader) *Reader{...}
func (b *Reader) ReadString(a byte) (string, error)//根据a这个标识符来分割分隔，比如'\n'
func (b *Reader) ReadSlice(a byte) (line []byte, err error)//根据关键词a切片
//还有ReadByte等各种方法，以此类推
```
(先了解到这)

---
`bytes`包和`strings`包的相关方法基本一致
`bytes.Trim(s []byte, cutset string) []byte`删除s切片中的cutset字段
同类的还有
`bytes.TrimLeft`
`bytes.TrimRight`
`bytes.TrimPrefix`
`bytes.TrimSuffix`等等

---
## gin
### **gin有关router的一些操作**
```
//初始化操作，方便添加新的路由
package routers


import "github.com/gin-gonic/gin"

type Register func(e *gin.Engine)

func Init(routers ...Register) *gin.Engine {

rs := append([]Register{}, routers...)

r := gin.New()

for _, register := range rs {

register(r)

}

return r

}
```

```
//这是用来加载路由的。可以每次编写一组路由对应一个loadrouter
package routers

  

import "github.com/gin-gonic/gin"

  

func LoadRouter1(e *gin.Engine) {

v1 := e.Group("v1")

{

v1.GET("/yes", Sayyes)

}

}
```
`:` 只能匹配1个，`*` 可以匹配任意个数

---

### **gin获取请求参数的一些操作**
GET获取请求参数：
`username := c.Query("username")`
-   DefaultQuery()若参数不存在，返回默认值，Query()若不存在，返回空串

POST获取请求参数--Form表单:
`username := c.PostForm("username")`
POST获取请求参数--JSON:
`var user User` 
`if err := c.BindJSON(&user);`
` err != nil { // 返回错误信息` 
`c.JSON(http.StatusBadRequest,gin.H{"error": err.Error()})` 
`return`
`}`
URL参数：
`username := c.Param("username")`
请求头部参数：
`username := c.Request.Header.Get("username")`

---
### **文件上传**
可以给表单限制上传大小：
`r.MaxMultipartMemory = 8 << 20 //8MiB`

```
package upload

  

import (

"fmt"

"net/http"

  

"github.com/gin-gonic/gin"

)

  

func Upload(c *gin.Context) {

file, err := c.FormFile("file")

if err != nil {

c.String(500, "上传文件出错")

return

}

  

// 直接保存上传的文件到目标文件夹

if err := c.SaveUploadedFile(file, "C:/myproject/RebootedJourney/gin/uploadfiles/"+file.Filename); err != nil {

c.String(500, "保存文件失败")

return

}

  

c.String(200, "上传成功，文件名："+file.Filename)

}

func Uploads(c *gin.Context) {

form, err := c.MultipartForm()

if err != nil {

c.String(http.StatusBadRequest, fmt.Sprintf("get err %s", err.Error()))

}

files := form.File["files"]

for _, file := range files {

if err := c.SaveUploadedFile(file, "C:/myproject/RebootedJourney/gin/uploadfiles/"+file.Filename); err != nil {

c.String(500, "保存失败:", file.Filename)

}

fmt.Println(file.Filename + "uploaded")

}

c.String(http.StatusOK, fmt.Sprintf("upload ok %d files", len(files)))

}
```
---

### **一些数据绑定的知识**
`ShouldBind()`
`ShouldBindJSON()`
数据绑定是将从请求端获取的数据和服务器的规范的数据结构进行匹配。
比如说：
```
type Login struct {

// binding:"required" 表示必须有符合项，不可忽略，否则报错

User string `form:"username" json:"user" uri:"user" xml:"user" binding:"required"`

Password string `form:"password" json:"password" uri:"password" xml:"password" binding:"required"`

}
r.POST("/loginJSON", func(c *gin.Context) {

var login Login

if err := c.ShouldBindJSON(&login); err != nil {

c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})

return

}

c.JSON(http.StatusOK, gin.H{

"status": 200,

"user": login.User,

"password": login.Password,

})

})
```
在上述的结构体中，tag的定义要求我们在调用loginJSON这个路由的时候，比如说发送一个json格式的报文，必须包括以下字段：
```
{
	"user": xxx
	"password": xxx
	......
}	
```

---
### **重定向**

- 状态码301,308是永久重定向。意思是如果之前访问的是 "/a/b" 这个URL，并且服务器返回了一个永久重定向到 "/a/c"，那么以后无论是手动输入 "/a/b" 还是通过链接跳转过来，浏览器都会自动将请求重定向到 "/a/c"，因为浏览器已经记下了这个重定向
  - 这导致了一个问题，假如说我的网站维修好了之后又将URL设置回/a/b，浏览器不清除缓存的情况下就会连接不上
  - 另外
- 状态码302,307是临时重定向。区别在于307会维护原请求，请求方法和消息主体不会发生变化。而302可能是重新发起请求，不再管之前的数据，还可能会把方法更改为GET
  - 302可以用于登录后转到新的网站界面，网站维护界面
  - 307可以用于身份验证，这样可以在验证之后保留数据用于访问之前的资源
- 304发送用于重新验证的条件请求。表示缓存的响应仍然是新的，可以继续使用

---
### **异步**
```
r.GET("/long_async", func(c *gin.Context) { 
// 需要搞一个副本
copyContext := c.Copy() 
// 异步处理 
go func() {
time.Sleep(3 * time.Second)
log.Println("异步执行：" + copyContext.Request.URL.Path) // 注意不能在这执行重定向的任务，不然panic 
}() 
})
```

---
### **cookie相关的**
**一些属性**
- domain：决定生效域。应该设置为.a.b.com
- path：如果domain都为.a.com，但是Path1=/b/，Path2=/b/c/，则a.com/b页面只能访问cookie1，a.com/b/c可以访问cookie1和cookie2
- Expires：cookie被删除的时间戳
- max-age： cookie过期时间。秒为单位，默认-1，表示页面关闭失效

**操作**
```
r.GET("/getCookie", func(c *gin.Context) {

	//先获取客户端是否携带cookie

	cookie, err := c.Cookie("key_cookie")

	if err != nil {

		cookie = "cookie"

		c.SetCookie("key_cookie", "value_cookie",

		60, //Max_Age

		"/", //path

		"localhost", //domain

		false, //secure

		true, //httpOnly

		)
		}
	fmt.Printf("cookie值为：%s", cookie)
	})
```

---
### **session**
`var store = cookie.NewStore([]byte("secret11111))`秘钥
`r.Use("mysession", store)`mysession既是cookie名也是session名
`session=sessions.Default()`初始化一个session
`session.Set("key",  "value")`设置session
`session.Save()`保存
`session.Delete("xxx")`删除
`session.Clear`清空
`session.Get("key")`获取对应的value

---
### **token**
自定义中间件要求返回一个handlerfunc类型:`type HandlerFunc func(*Context)`
```
func MyLogMiddleware() (gin.HandlerFunc) {
	return func(c *gin.Context) {
		fmt.Println("[Mylog] 用户IP:", c.ClinetIP())
		fmt.Println("[Mylog] 用户request:", c.Request())
		}
```
`next()`函数会跳过当前中间件中next()后的逻辑，当**下一个中间件执行完成后**再执行剩余的逻辑。假设注册中间件的顺序为m1,m2,m3
则执行顺序为m1的next()之前-->m2的next()之前-->m3的next()之前-->业务逻辑-->-->m1的next()之后-->m2的next()之后-->m3的next()之后
`abort()`函数执行终止当前中间件以后的中间件执行，**但是会执行当前中间件的后续逻辑**比如说m2调用Abort()，则m3和业务逻辑不执行，但m2和m1按照上面next()的顺序执行。

**局部中间件的使用**：
`r.GET("/test", MyLogMiddleWare(), func(c *gin.Context) {`
```
v1 := r.Group("v1", MyLogMiddleWare()) 
// 也可以这样书写 
// v1.Use(MyLogMiddleWare()) 
v1.GET("/c1", func(c *gin.Context) {
```
**中间件处理后续工作**：
```
func CalcTimeMiddleware() (gin.HandlerFunc) {
	return func(c *gin.Context) {
		start := time.Now()
		c.Next()
		since := time.Since(start)
		fmt.Println("程序用时：", since)
	}
}
```

**中间件进行身份验证**
```
func AuthMiddleware() (gin.HandlerFunc) {
	return func(c *gin.Context) {
		if cookie, err := c.Cookie("key_cookie); err == nil {
			if cookie == "value_cookie" {
				return
			}
		}
		c.JSON(http.StatusUnauthorized, gin.H("error": "err"))
		c.Abort()
```


 
*cookie和session的知识需要复习！*
## gorm！
### **先把postgresql的知识搞一下**
`psql -U postgres;`以postgres用户登录
`CREATE database codeplay;`创建数据库
`\c codeplay`（不用";"）进入数据库codeplay
`\l`查看有哪些数据库
`\q`退出数据库
`\dt`可以查看当前数据库中的所有表和相关信息
```
CREATE TABLE rooms (
	id SERIAL PRIMARY KEY,
	floor INTEGER,
	mates VARCHAR(100)
);
```
创建表
```
INSERT INTO rooms (id, floor, mates) 
VALUES (510, 5, 'ysy,  yzx, cz, xbr');//可以不要(id, floor, mates)，主要是用于确定顺序
```
插入数据
`UPDATE rooms SET floor = 6 WHERE id = 510;`
更新数据
`DELETE FROM rooms WHERE id = 510;`
删除数据
`COPY rooms FROM '/home/user/rooms.txt';`
可以拷贝大量数据
```
SELECT 表达式 FROM rooms
	WHERE 条件 AND/OR/NOT 条件
	ORDER BY floor(排序标准)；
```
单表查询
```
 SELECT weather.city, weather.temp_lo, weather.temp_hi,
       weather.prcp, weather.date, cities.location
    FROM weather, cities
    WHERE cities.name = weather.city;
```
多表连接
- 内连接：
`INNER JOIN xx ON (x.a=y.b)`
只保留能够匹配的数据
- 左连接：
	`LEFT (OUTER) JOIN` 
	保留左表的每条数据，右表不符合条件的返回NULL
- 右连接：
	`RIGHT (OUTER) JOIN`
	保留右表的每条数据，左表不符合条件的返回NULL
- 全连接：
	`FULL JOIN`
	左右连接的合并
- 交叉连接：
	`CROSS JOIN`(或`1 JOIN 2`,`1, 2`)
	笛卡尔积。举个例子：
	表1是student表，表2是teacher表。这样1 CROSS JOIN 2 可以得到每个学生分别和不同科目老师组合的信息
子查询：
```
SELECT city FROM weather
	WHERE temp_lo = (SELECT max(temp_lo) FROM weather);
```

### **基础操作**

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTI5MDUxNzM3NiwxNjkxOTM5ODMsLTE4MT
k4MTg2MzAsLTg5OTg4MDE1NSwtNDY2MTAxNzMxLC0yMDkxOTQx
MDAyLDE3MzEwNTMwMDksMTA1NTcyNDE4OSwtMTA3MDkyMjg5MC
w0NTQ4MzU5MTMsMTQ5ODA2MTk5OCwtMTY5MTk3Mjc2MiwxODQy
MzY0NDg4LC0xMzI5OTkyMTU2LC0xNDI4NjQzMDA4LC0xMjY2MT
Y1MzEzLDE3MDk0OTM5MzgsLTEyOTU1OTA5MTYsLTEzMTA2NzM5
MjYsLTgwNzYwMDgzXX0=
-->